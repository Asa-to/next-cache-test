Hono server は `bun build [entrypoint] --outdir [outdir]`でビルドする。

実行は`bun index.js`。

Next.js はちゃんとビルドして本番モードで動かさないとキャッシュ機構が意図通りに動かないのでそうする。ちなみに`bun run build`としないと bun 独自のビルド機能の方が走る。

# Next.js のキャッシュのありがたさを体感する会

改めて Next.js のキャッシュについて

1. インメモリキャッシュ
   1. レンダリング中の同一リクエストは 1 回にまとめられる
2. フェッチデータキャッシュ
   1. キャッシュ設定に応じて API へのリクエストをキャッシュする
3. フルルートキャッシュ
   1. フェッチデータキャッシュの応用で、更新する必要がなければ生成した HTML と RSC ペイロードもキャッシュしてくれる
4. ルートキャッシュ
   1. これはプリフェッチ

# キャッシュを感じてみる方法

API サーバーは/api/[route]みたいな感じでエンドポイントを作って、json 形式で{ data: [route] }みたいな感じで値を返す。

リクエストが来たら YYYY/MM/DD/s: [route]のフォーマットでログを出力する

dev モードでは効かないので、試すときはちゃんとビルドして start する。

## インメモリキャッシュ

同じエンドポイントへたくさんリクエストをするコンポーネントを作ればいいだけ。

エンドポイントからはまあ適当な値を返して、リクエストが来るたびにログを排出する。レンダリング中に一度しかログが出なければ一回しかリクエストが来てないことになる。

### 結果

Page.tsx に同一エンドポイントへのリクエストを行うコンポーネントを作って試してみた。

| fetch 設定  | ビルド時 | ページアクセス時 |
| ----------- | -------- | ---------------- |
| no-cache    | 1 回     | 1 回             |
| force-cache | 1 回     | 0 回             |

## フェッチデータキャッシュ

キャッシュ設定をちゃんとやって、データ fetch を伴うコンポーネントを表示するページをリロードしまくればいい。

またこれも API Server のログを見て判断する

| fetch 設定  | ビルド時 | ページアクセス時 |
| ----------- | -------- | ---------------- |
| no-cache    | 1 回     | 1 回             |
| force-cache | 1 回     | 0 回             |

fetch に cookie を含めた場合、cookie を変更すると新しくデータをちゃんと fetch することが確認できた。

## フルルートキャッシュ

まあ別に API リクエストのキャッシュとは直接関係ないと思うからどうでもいいかも。

## ルートキャッシュ

大変そうだから一旦考えない。初めは切っとく。
